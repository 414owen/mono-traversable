-- WARNING: This module is autogenerated
{-# OPTIONS_HADDOCK not-home #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE MultiParamTypeClasses     #-}
{-# LANGUAGE NoImplicitPrelude         #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE BangPatterns #-}
module Data.Conduit.Combinators.Unqualified
    ( -- ** Producers
      -- *** Pure
      yieldMany
    , unfoldC
    , enumFromToC
    , iterateC
    , repeatC
    , replicateC
    , sourceLazy

      -- *** Monadic
    , repeatMC
    , repeatWhileMC
    , replicateMC

      -- *** I\/O
    , sourceFile
    , sourceFileBS
    , sourceHandle
    , sourceIOHandle
    , stdinC
    , withSourceFileC

      -- *** Random numbers
    , sourceRandom
    , sourceRandomN
    , sourceRandomGen
    , sourceRandomNGen
    , sourceRandomWith
    , sourceRandomNWith
    , sourceRandomGenWith
    , sourceRandomNGenWith

      -- *** Filesystem
    , sourceDirectory
    , sourceDirectoryDeep

      -- ** Consumers
      -- *** Pure
    , dropC
    , dropCE
    , dropWhileC
    , dropWhileCE
    , foldC
    , foldCE
    , foldlC
    , foldl1C
    , foldlCE
    , foldMapC
    , foldMapCE
    , allC
    , allCE
    , anyC
    , anyCE
    , andC
    , andCE
    , orC
    , orCE
    , asumC
    , elemC
    , elemCE
    , notElemC
    , notElemCE
    , sinkLazy
    , sinkList
    , sinkVector
    , sinkVectorN
    , sinkBuilder
    , sinkLazyBuilder
    , sinkNull
    , awaitNonNull
    , headC
    , headDefC
    , headCE
    , peekC
    , peekCE
    , lastC
    , lastDefC
    , lastCE
    , lengthC
    , lengthCE
    , lengthIfC
    , lengthIfCE
    , maximumC
    , maximumCE
    , minimumC
    , minimumCE
    , nullC
    , nullCE
    , sumC
    , sumCE
    , productC
    , productCE
    , findC

      -- *** Monadic
    , mapM_C
    , mapM_CE
    , foldMC
    , foldMCE
    , foldMapMC
    , foldMapMCE

      -- *** I\/O
    , sinkFile
    , sinkFileBS
    , sinkHandle
    , sinkIOHandle
    , printC
    , stdoutC
    , stderrC
    , withSinkFileC
    , withSinkFileBuilderC
    , sinkHandleBuilder
    , sinkHandleFlush

      -- ** Transformers
      -- *** Pure
    , mapC
    , mapCE
    , omapCE
    , concatMapC
    , concatMapCE
    , takeC
    , takeCE
    , takeWhileC
    , takeWhileCE
    , takeExactlyC
    , takeExactlyCE
    , concatC
    , filterC
    , filterCE
    , mapWhileC
    , conduitVector
    , scanlC
    , mapAccumWhileC
    , concatMapAccumC
    , intersperseC
    , slidingWindowC
    , chunksOfCE
    , chunksOfExactlyCE

      -- **** Binary base encoding
    , encodeBase64C
    , decodeBase64C
    , encodeBase64URLC
    , decodeBase64URLC
    , encodeBase16C
    , decodeBase16C

      -- *** Monadic
    , mapMC
    , mapMCE
    , omapMCE
    , concatMapMC
    , filterMC
    , filterMCE
    , iterMC
    , scanlMC
    , mapAccumWhileMC
    , concatMapAccumMC

      -- *** Textual
    , encodeUtf8C
    , decodeUtf8C
    , decodeUtf8LenientC
    , lineC
    , lineAsciiC
    , unlinesC
    , unlinesAsciiC
    , takeExactlyUntilCE
    , linesUnboundedC
    , linesUnboundedAsciiC
    , splitOnUnboundedCE

      -- ** Special
    , vectorBuilderC
    , mapAccumSC
    , peekForeverC
    , peekForeverCE
    ) where

-- BEGIN IMPORTS

import qualified Data.Conduit.Combinators as CC
-- BEGIN IMPORTS

import Data.Builder
import qualified Data.NonNull as NonNull
import qualified Data.Traversable
import qualified Data.ByteString as S
import qualified Data.ByteString.Base16 as B16
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Base64.URL as B64U
import           Control.Applicative         (Alternative(..), (<$>))
import           Control.Exception           (assert)
import           Control.Category            (Category (..))
import           Control.Monad               (unless, when, (>=>), liftM, forever)
import           Control.Monad.IO.Class      (MonadIO (..))
import           Control.Monad.Primitive     (PrimMonad, PrimState)
import           Control.Monad.Trans.Class   (lift)
import           Control.Monad.Trans.Resource (MonadResource, MonadThrow)
import           Data.Conduit
import           Data.Conduit.Binary         (sourceFile, sourceHandle, sourceIOHandle,
                                              sinkFile, sinkHandle)
import qualified Data.Conduit.Binary     as CB
import qualified Data.Conduit.Filesystem as CF
import           Data.Conduit.Internal       (ConduitT (..), Pipe (..))
import qualified Data.Conduit.List           as CL
import           Data.Maybe                  (fromMaybe, isNothing, isJust)
import           Data.Monoid                 (Monoid (..))
import           Data.MonoTraversable
import qualified Data.Sequences              as Seq
import qualified Data.Vector.Generic         as V
import qualified Data.Vector.Generic.Mutable as VM
import           Data.Void                   (absurd)
import           Prelude                     (Bool (..), Eq (..), Int,
                                              Maybe (..), Either (..), Monad (..), Num (..),
                                              Ord (..), fromIntegral, maybe, either,
                                              ($), Functor (..), Enum, seq, Show, Char,
                                              mod, otherwise, Either (..),
                                              ($!), succ, FilePath)
import Data.Word (Word8)
import qualified Prelude
import qualified System.IO                   as SIO
import qualified Data.Conduit.Text as CT
import Data.ByteString (ByteString)
import Data.Text (Text)
import qualified System.Random.MWC as MWC
import Data.Conduit.Combinators.Internal
import Data.Conduit.Combinators.Stream
import Data.Conduit.Internal.Fusion
import           Data.Primitive.MutVar       (MutVar, newMutVar, readMutVar,
                                              writeMutVar)

import qualified Data.Sequences as DTE
import           Data.Sequences (LazySequence (..))

-- Defines INLINE_RULE0, INLINE_RULE, STREAMING0, and STREAMING.
#include "fusion-macros.h"


-- | See 'CC.yieldMany'
yieldMany = CC.yieldMany
{-# INLINE yieldMany #-}

-- | Generate a producer from a seed value.
--
-- Subject to fusion
--
-- Since 1.0.0
unfoldC :: Monad m
       => (b -> Maybe (a, b))
       -> b
       -> ConduitT i a m ()
unfoldC = CC.unfold
{-# INLINE unfoldC #-}

-- | Enumerate from a value to a final value, inclusive, via 'succ'.
--
-- This is generally more efficient than using @Prelude@\'s @enumFromTo@ and
-- combining with @sourceList@ since this avoids any intermediate data
-- structures.
--
-- Subject to fusion
--
-- Since 1.0.0
enumFromToC :: (Monad m, Enum a, Ord a) => a -> a -> ConduitT i a m ()
enumFromToC = CC.enumFromTo
{-# INLINE enumFromToC #-}

-- | Produces an infinite stream of repeated applications of f to x.
--
-- Subject to fusion
--
-- Since 1.0.0
iterateC :: Monad m => (a -> a) -> a -> ConduitT i a m ()
iterateC = CC.iterate
{-# INLINE iterateC #-}

-- | Produce an infinite stream consisting entirely of the given value.
--
-- Subject to fusion
--
-- Since 1.0.0
repeatC :: Monad m => a -> ConduitT i a m ()
repeatC = CC.repeat
{-# INLINE repeatC #-}

-- | Produce a finite stream consisting of n copies of the given value.
--
-- Subject to fusion
--
-- Since 1.0.0
replicateC :: Monad m
          => Int
          -> a
          -> ConduitT i a m ()
replicateC = CC.replicate
{-# INLINE replicateC #-}

-- | Generate a producer by yielding each of the strict chunks in a @LazySequence@.
--
-- For more information, see 'toChunks'.
--
-- Subject to fusion
--
-- Since 1.0.0
sourceLazy :: (Monad m, LazySequence lazy strict)
           => lazy
           -> ConduitT i strict m ()
sourceLazy = CC.sourceLazy
{-# INLINE sourceLazy #-}

-- | See 'CC.repeatM'
repeatMC = CC.repeatM
{-# INLINE repeatMC #-}

-- | See 'CC.repeatWhileM'
repeatWhileMC = CC.repeatWhileM
{-# INLINE repeatWhileMC #-}

-- | Perform the given action n times, yielding each result.
--
-- Subject to fusion
--
-- Since 1.0.0
replicateMC :: Monad m
           => Int
           -> m a
           -> ConduitT i a m ()
replicateMC = CC.replicateM
{-# INLINE replicateMC #-}

-- | See 'CC.sourceFile'
sourceFile = CC.sourceFile
{-# INLINE sourceFile #-}

-- | 'sourceFile' specialized to 'ByteString' to help with type
-- inference.
--
-- @since 1.0.7
sourceFileBS :: MonadResource m => FilePath -> ConduitT i ByteString m ()
sourceFileBS = CC.sourceFileBS
{-# INLINE sourceFileBS #-}

-- | See 'CC.sourceHandle'
sourceHandle = CC.sourceHandle
{-# INLINE sourceHandle #-}

-- | See 'CC.sourceIOHandle'
sourceIOHandle = CC.sourceIOHandle
{-# INLINE sourceIOHandle #-}

-- | @sourceHandle@ applied to @stdin@.
--
-- Subject to fusion
--
-- Since 1.0.0
stdinC :: MonadIO m => ConduitT i ByteString m ()
stdinC = CC.stdin
{-# INLINE stdinC #-}

-- | See 'CC.withSourceFile'
withSourceFileC = CC.withSourceFile
{-# INLINE withSourceFileC #-}

-- | Create an infinite stream of random values, seeding from the system random
-- number.
--
-- Subject to fusion
--
-- Since 1.0.0
sourceRandom :: (MWC.Variate a, MonadIO m) => ConduitT i a m ()
sourceRandom = CC.sourceRandom
{-# INLINE sourceRandom #-}

-- | Create a stream of random values of length n, seeding from the system
-- random number.
--
-- Subject to fusion
--
-- Since 1.0.0
sourceRandomN :: (MWC.Variate a, MonadIO m)
              => Int -- ^ count
              -> ConduitT i a m ()
sourceRandomN = CC.sourceRandomN
{-# INLINE sourceRandomN #-}

-- | Create an infinite stream of random values, using the given random number
-- generator.
--
-- Subject to fusion
--
-- Since 1.0.0
sourceRandomGen :: (MWC.Variate a, PrimMonad m)
                => MWC.Gen (PrimState m)
                -> ConduitT i a m ()
sourceRandomGen = CC.sourceRandomGen
{-# INLINE sourceRandomGen #-}

-- | Create a stream of random values of length n, seeding from the system
-- random number.
--
-- Subject to fusion
--
-- Since 1.0.0
sourceRandomNGen :: (MWC.Variate a, PrimMonad m)
                 => MWC.Gen (PrimState m)
                 -> Int -- ^ count
                 -> ConduitT i a m ()
sourceRandomNGen = CC.sourceRandomNGen
{-# INLINE sourceRandomNGen #-}

-- | Create an infinite stream of random values from an arbitrary distribution,
-- seeding from the system random number.
--
-- Subject to fusion
--
-- Since 1.0.3
sourceRandomWith :: (MWC.Variate a, MonadIO m) => (MWC.GenIO -> SIO.IO a) -> ConduitT i a m ()
sourceRandomWith = CC.sourceRandomWith
{-# INLINE sourceRandomWith #-}

-- | Create a stream of random values of length n from an arbitrary
-- distribution, seeding from the system random number.
--
-- Subject to fusion
--
-- Since 1.0.3
sourceRandomNWith :: (MWC.Variate a, MonadIO m)
                  => Int -- ^ count
                  -> (MWC.GenIO -> SIO.IO a)
                  -> ConduitT i a m ()
sourceRandomNWith = CC.sourceRandomNWith
{-# INLINE sourceRandomNWith #-}

-- | Create an infinite stream of random values from an arbitrary distribution,
-- using the given random number generator.
--
-- Subject to fusion
--
-- Since 1.0.3
sourceRandomGenWith :: (MWC.Variate a, PrimMonad m)
                    => MWC.Gen (PrimState m)
                    -> (MWC.Gen (PrimState m) -> m a)
                    -> ConduitT i a m ()
sourceRandomGenWith = CC.sourceRandomGenWith
{-# INLINE sourceRandomGenWith #-}

-- | Create a stream of random values of length n from an arbitrary
-- distribution, seeding from the system random number.
--
-- Subject to fusion
--
-- Since 1.0.3
sourceRandomNGenWith :: (MWC.Variate a, PrimMonad m)
                     => MWC.Gen (PrimState m)
                     -> Int -- ^ count
                     -> (MWC.Gen (PrimState m) -> m a)
                     -> ConduitT i a m ()
sourceRandomNGenWith = CC.sourceRandomNGenWith
{-# INLINE sourceRandomNGenWith #-}

-- | Stream the contents of the given directory, without traversing deeply.
--
-- This function will return /all/ of the contents of the directory, whether
-- they be files, directories, etc.
--
-- Note that the generated filepaths will be the complete path, not just the
-- filename. In other words, if you have a directory @foo@ containing files
-- @bar@ and @baz@, and you use @sourceDirectory@ on @foo@, the results will be
-- @foo/bar@ and @foo/baz@.
--
-- Since 1.0.0
sourceDirectory :: MonadResource m => FilePath -> ConduitT i FilePath m ()
sourceDirectory = CC.sourceDirectory
{-# INLINE sourceDirectory #-}

-- | Deeply stream the contents of the given directory.
--
-- This works the same as @sourceDirectory@, but will not return directories at
-- all. This function also takes an extra parameter to indicate whether
-- symlinks will be followed.
--
-- Since 1.0.0
sourceDirectoryDeep :: MonadResource m
                    => Bool -- ^ Follow directory symlinks
                    -> FilePath -- ^ Root directory
                    -> ConduitT i FilePath m ()
sourceDirectoryDeep = CC.sourceDirectoryDeep
{-# INLINE sourceDirectoryDeep #-}

-- | Ignore a certain number of values in the stream.
--
-- Since 1.0.0
dropC :: Monad m
     => Int
     -> ConduitT a o m ()
dropC = CC.drop
{-# INLINE dropC #-}

-- | Drop a certain number of elements from a chunked stream.
--
-- Since 1.0.0
dropCE :: (Monad m, Seq.IsSequence seq)
      => Seq.Index seq
      -> ConduitT seq o m ()
dropCE = CC.dropE
{-# INLINE dropCE #-}

-- | Drop all values which match the given predicate.
--
-- Since 1.0.0
dropWhileC :: Monad m
          => (a -> Bool)
          -> ConduitT a o m ()
dropWhileC = CC.dropWhile
{-# INLINE dropWhileC #-}

-- | Drop all elements in the chunked stream which match the given predicate.
--
-- Since 1.0.0
dropWhileCE :: (Monad m, Seq.IsSequence seq)
           => (Element seq -> Bool)
           -> ConduitT seq o m ()
dropWhileCE = CC.dropWhileE
{-# INLINE dropWhileCE #-}

-- | Monoidally combine all values in the stream.
--
-- Subject to fusion
--
-- Since 1.0.0
foldC :: (Monad m, Monoid a)
     => ConduitT a o m a
foldC = CC.fold
{-# INLINE foldC #-}

-- | Monoidally combine all elements in the chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
foldCE :: (Monad m, MonoFoldable mono, Monoid (Element mono))
      => ConduitT mono o m (Element mono)
foldCE = CC.foldE
{-# INLINE foldCE #-}

-- | A strict left fold.
--
-- Subject to fusion
--
-- Since 1.0.0
foldlC :: Monad m => (a -> b -> a) -> a -> ConduitT b o m a
foldlC = CC.foldl
{-# INLINE foldlC #-}

-- | See 'CC.foldl1'
foldl1C = CC.foldl1
{-# INLINE foldl1C #-}

-- | A strict left fold on a chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
foldlCE :: (Monad m, MonoFoldable mono)
       => (a -> Element mono -> a)
       -> a
       -> ConduitT mono o m a
foldlCE = CC.foldlE
{-# INLINE foldlCE #-}

-- | Apply the provided mapping function and monoidal combine all values.
--
-- Subject to fusion
--
-- Since 1.0.0
foldMapC :: (Monad m, Monoid b)
        => (a -> b)
        -> ConduitT a o m b
foldMapC = CC.foldMap
{-# INLINE foldMapC #-}

-- | Apply the provided mapping function and monoidal combine all elements of the chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
foldMapCE :: (Monad m, MonoFoldable mono, Monoid w)
         => (Element mono -> w)
         -> ConduitT mono o m w
foldMapCE = CC.foldMapE
{-# INLINE foldMapCE #-}

-- | See 'CC.all'
allC = CC.all
{-# INLINE allC #-}

-- | Check that all elements in the chunked stream return True.
--
-- Subject to shortcut logic: at the first False, consumption of the stream
-- will stop.
--
-- Subject to fusion
--
-- Since 1.0.0
allCE :: (Monad m, MonoFoldable mono)
     => (Element mono -> Bool)
     -> ConduitT mono o m Bool
allCE = CC.allE
{-# INLINE allCE #-}

-- | See 'CC.any'
anyC = CC.any
{-# INLINE anyC #-}

-- | Check that at least one element in the chunked stream returns True.
--
-- Subject to shortcut logic: at the first True, consumption of the stream
-- will stop.
--
-- Subject to fusion
--
-- Since 1.0.0
anyCE :: (Monad m, MonoFoldable mono)
     => (Element mono -> Bool)
     -> ConduitT mono o m Bool
anyCE = CC.anyE
{-# INLINE anyCE #-}

-- | Are all values in the stream True?
--
-- Consumption stops once the first False is encountered.
--
-- Subject to fusion
--
-- Since 1.0.0
andC :: Monad m => ConduitT Bool o m Bool
andC = CC.and
{-# INLINE andC #-}

-- | Are all elements in the chunked stream True?
--
-- Consumption stops once the first False is encountered.
--
-- Subject to fusion
--
-- Since 1.0.0
andCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool)
     => ConduitT mono o m Bool
andCE = CC.andE
{-# INLINE andCE #-}

-- | Are any values in the stream True?
--
-- Consumption stops once the first True is encountered.
--
-- Subject to fusion
--
-- Since 1.0.0
orC :: Monad m => ConduitT Bool o m Bool
orC = CC.or
{-# INLINE orC #-}

-- | Are any elements in the chunked stream True?
--
-- Consumption stops once the first True is encountered.
--
-- Subject to fusion
--
-- Since 1.0.0
orCE :: (Monad m, MonoFoldable mono, Element mono ~ Bool)
    => ConduitT mono o m Bool
orCE = CC.orE
{-# INLINE orCE #-}

-- | 'Alternative'ly combine all values in the stream.
--
-- Since 1.1.1
asumC :: (Monad m, Alternative f)
     => ConduitT (f a) o m (f a)
asumC = CC.asum
{-# INLINE asumC #-}

-- | See 'CC.elem'
elemC = CC.elem
{-# INLINE elemC #-}

-- | Are any elements in the chunked stream equal to the given element?
--
-- Stops consuming as soon as a match is found.
--
-- Subject to fusion
--
-- Since 1.0.0
elemCE :: (Monad m, Seq.IsSequence seq, Eq (Element seq))
      => Element seq
      -> ConduitT seq o m Bool
elemCE = CC.elemE
{-# INLINE elemCE #-}

-- | See 'CC.notElem'
notElemC = CC.notElem
{-# INLINE notElemC #-}

-- | Are no elements in the chunked stream equal to the given element?
--
-- Stops consuming as soon as a match is found.
--
-- Subject to fusion
--
-- Since 1.0.0
notElemCE :: (Monad m, Seq.IsSequence seq, Eq (Element seq))
         => Element seq
         -> ConduitT seq o m Bool
notElemCE = CC.notElemE
{-# INLINE notElemCE #-}

-- | See 'CC.sinkLazy'
sinkLazy = CC.sinkLazy
{-# INLINE sinkLazy #-}

-- | Consume all values from the stream and return as a list. Note that this
-- will pull all values into memory.
--
-- Subject to fusion
--
-- Since 1.0.0
sinkList :: Monad m => ConduitT a o m [a]
sinkList = CC.sinkList
{-# INLINE sinkList #-}

-- | See 'CC.sinkVector'
sinkVector = CC.sinkVector
{-# INLINE sinkVector #-}

-- | See 'CC.sinkVectorN'
sinkVectorN = CC.sinkVectorN
{-# INLINE sinkVectorN #-}

-- | Convert incoming values to a builder and fold together all builder values.
--
-- Defined as: @foldMap toBuilder@.
--
-- Subject to fusion
--
-- Since 1.0.0
sinkBuilder :: (Monad m, Monoid builder, ToBuilder a builder)
            => ConduitT a o m builder
sinkBuilder = CC.sinkBuilder
{-# INLINE sinkBuilder #-}

-- | See 'CC.sinkLazyBuilder'
sinkLazyBuilder = CC.sinkLazyBuilder
{-# INLINE sinkLazyBuilder #-}

-- | Consume and discard all remaining values in the stream.
--
-- Subject to fusion
--
-- Since 1.0.0
sinkNull :: Monad m => ConduitT a o m ()
sinkNull = CC.sinkNull
{-# INLINE sinkNull #-}

-- | Same as @await@, but discards any leading 'onull' values.
--
-- Since 1.0.0
awaitNonNull :: (Monad m, MonoFoldable a) => ConduitT a o m (Maybe (NonNull.NonNull a))
awaitNonNull = CC.awaitNonNull
{-# INLINE awaitNonNull #-}

-- | Take a single value from the stream, if available.
--
-- Since 1.0.5
headC :: Monad m => ConduitT a o m (Maybe a)
headC = CC.head
{-# INLINE headC #-}

-- | Same as 'head', but returns a default value if none are available from the stream.
--
-- Since 1.0.5
headDefC :: Monad m => a -> ConduitT a o m a
headDefC = CC.headDef
{-# INLINE headDefC #-}

-- | Get the next element in the chunked stream.
--
-- Since 1.0.0
headCE :: (Monad m, Seq.IsSequence seq) => ConduitT seq o m (Maybe (Element seq))
headCE = CC.headE
{-# INLINE headCE #-}

-- | View the next value in the stream without consuming it.
--
-- Since 1.0.0
peekC :: Monad m => ConduitT a o m (Maybe a)
peekC = CC.peek
{-# INLINE peekC #-}

-- | View the next element in the chunked stream without consuming it.
--
-- Since 1.0.0
peekCE :: (Monad m, MonoFoldable mono) => ConduitT mono o m (Maybe (Element mono))
peekCE = CC.peekE
{-# INLINE peekCE #-}

-- | See 'CC.last'
lastC = CC.last
{-# INLINE lastC #-}

-- | Same as 'last', but returns a default value if none are available from the stream.
--
-- Since 1.0.5
lastDefC :: Monad m => a -> ConduitT a o m a
lastDefC = CC.lastDef
{-# INLINE lastDefC #-}

-- | See 'CC.lastE'
lastCE = CC.lastE
{-# INLINE lastCE #-}

-- | Count how many values are in the stream.
--
-- Subject to fusion
--
-- Since 1.0.0
lengthC :: (Monad m, Num len) => ConduitT a o m len
lengthC = CC.length
{-# INLINE lengthC #-}

-- | Count how many elements are in the chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
lengthCE :: (Monad m, Num len, MonoFoldable mono) => ConduitT mono o m len
lengthCE = CC.lengthE
{-# INLINE lengthCE #-}

-- | Count how many values in the stream pass the given predicate.
--
-- Subject to fusion
--
-- Since 1.0.0
lengthIfC :: (Monad m, Num len) => (a -> Bool) -> ConduitT a o m len
lengthIfC = CC.lengthIf
{-# INLINE lengthIfC #-}

-- | Count how many elements in the chunked stream pass the given predicate.
--
-- Subject to fusion
--
-- Since 1.0.0
lengthIfCE :: (Monad m, Num len, MonoFoldable mono)
          => (Element mono -> Bool) -> ConduitT mono o m len
lengthIfCE = CC.lengthIfE
{-# INLINE lengthIfCE #-}

-- | Get the largest value in the stream, if present.
--
-- Subject to fusion
--
-- Since 1.0.0
maximumC :: (Monad m, Ord a) => ConduitT a o m (Maybe a)
maximumC = CC.maximum
{-# INLINE maximumC #-}

-- | Get the largest element in the chunked stream, if present.
--
-- Subject to fusion
--
-- Since 1.0.0
maximumCE :: (Monad m, Seq.IsSequence seq, Ord (Element seq)) => ConduitT seq o m (Maybe (Element seq))
maximumCE = CC.maximumE
{-# INLINE maximumCE #-}

-- | Get the smallest value in the stream, if present.
--
-- Subject to fusion
--
-- Since 1.0.0
minimumC :: (Monad m, Ord a) => ConduitT a o m (Maybe a)
minimumC = CC.minimum
{-# INLINE minimumC #-}

-- | Get the smallest element in the chunked stream, if present.
--
-- Subject to fusion
--
-- Since 1.0.0
minimumCE :: (Monad m, Seq.IsSequence seq, Ord (Element seq)) => ConduitT seq o m (Maybe (Element seq))
minimumCE = CC.minimumE
{-# INLINE minimumCE #-}

-- | True if there are no values in the stream.
--
-- This function does not modify the stream.
--
-- Since 1.0.0
nullC :: Monad m => ConduitT a o m Bool
nullC = CC.null
{-# INLINE nullC #-}

-- | True if there are no elements in the chunked stream.
--
-- This function may remove empty leading chunks from the stream, but otherwise
-- will not modify it.
--
-- Since 1.0.0
nullCE :: (Monad m, MonoFoldable mono)
      => ConduitT mono o m Bool
nullCE = CC.nullE
{-# INLINE nullCE #-}

-- | Get the sum of all values in the stream.
--
-- Subject to fusion
--
-- Since 1.0.0
sumC :: (Monad m, Num a) => ConduitT a o m a
sumC = CC.sum
{-# INLINE sumC #-}

-- | Get the sum of all elements in the chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
sumCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => ConduitT mono o m (Element mono)
sumCE = CC.sumE
{-# INLINE sumCE #-}

-- | Get the product of all values in the stream.
--
-- Subject to fusion
--
-- Since 1.0.0
productC :: (Monad m, Num a) => ConduitT a o m a
productC = CC.product
{-# INLINE productC #-}

-- | Get the product of all elements in the chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
productCE :: (Monad m, MonoFoldable mono, Num (Element mono)) => ConduitT mono o m (Element mono)
productCE = CC.productE
{-# INLINE productCE #-}

-- | See 'CC.find'
findC = CC.find
{-# INLINE findC #-}

-- | Apply the action to all values in the stream.
--
-- Subject to fusion
--
-- Since 1.0.0
mapM_C :: Monad m => (a -> m ()) -> ConduitT a o m ()
mapM_C = CC.mapM_
{-# INLINE mapM_C #-}

-- | Apply the action to all elements in the chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
mapM_CE :: (Monad m, MonoFoldable mono) => (Element mono -> m ()) -> ConduitT mono o m ()
mapM_CE = CC.mapM_E
{-# INLINE mapM_CE #-}

-- | A monadic strict left fold.
--
-- Subject to fusion
--
-- Since 1.0.0
foldMC :: Monad m => (a -> b -> m a) -> a -> ConduitT b o m a
foldMC = CC.foldM
{-# INLINE foldMC #-}

-- | A monadic strict left fold on a chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
foldMCE :: (Monad m, MonoFoldable mono)
       => (a -> Element mono -> m a)
       -> a
       -> ConduitT mono o m a
foldMCE = CC.foldME
{-# INLINE foldMCE #-}

-- | Apply the provided monadic mapping function and monoidal combine all values.
--
-- Subject to fusion
--
-- Since 1.0.0
foldMapMC :: (Monad m, Monoid w) => (a -> m w) -> ConduitT a o m w
foldMapMC = CC.foldMapM
{-# INLINE foldMapMC #-}

-- | Apply the provided monadic mapping function and monoidal combine all
-- elements in the chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
foldMapMCE :: (Monad m, MonoFoldable mono, Monoid w)
          => (Element mono -> m w)
          -> ConduitT mono o m w
foldMapMCE = CC.foldMapME
{-# INLINE foldMapMCE #-}

-- | See 'CC.sinkFile'
sinkFile = CC.sinkFile
{-# INLINE sinkFile #-}

-- | 'sinkFile' specialized to 'ByteString' to help with type
-- inference.
--
-- @since 1.0.7
sinkFileBS :: MonadResource m => FilePath -> ConduitT ByteString o m ()
sinkFileBS = CC.sinkFileBS
{-# INLINE sinkFileBS #-}

-- | See 'CC.sinkHandle'
sinkHandle = CC.sinkHandle
{-# INLINE sinkHandle #-}

-- | See 'CC.sinkIOHandle'
sinkIOHandle = CC.sinkIOHandle
{-# INLINE sinkIOHandle #-}

-- | Print all incoming values to stdout.
--
-- Subject to fusion
--
-- Since 1.0.0
printC :: (Show a, MonadIO m) => ConduitT a o m ()
printC = CC.print
{-# INLINE printC #-}

-- | @sinkHandle@ applied to @stdout@.
--
-- Subject to fusion
--
-- Since 1.0.0
stdoutC :: MonadIO m => ConduitT ByteString o m ()
stdoutC = CC.stdout
{-# INLINE stdoutC #-}

-- | @sinkHandle@ applied to @stderr@.
--
-- Subject to fusion
--
-- Since 1.0.0
stderrC :: MonadIO m => ConduitT ByteString o m ()
stderrC = CC.stderr
{-# INLINE stderrC #-}

-- | See 'CC.withSinkFile'
withSinkFileC = CC.withSinkFile
{-# INLINE withSinkFileC #-}

-- | See 'CC.withSinkFileBuilder'
withSinkFileBuilderC = CC.withSinkFileBuilder
{-# INLINE withSinkFileBuilderC #-}

-- | See 'CC.sinkHandleBuilder'
sinkHandleBuilder = CC.sinkHandleBuilder
{-# INLINE sinkHandleBuilder #-}

-- | See 'CC.sinkHandleFlush'
sinkHandleFlush = CC.sinkHandleFlush
{-# INLINE sinkHandleFlush #-}

-- | Apply a transformation to all values in a stream.
--
-- Subject to fusion
--
-- Since 1.0.0
mapC :: Monad m => (a -> b) -> ConduitT a b m ()
mapC = CC.map
{-# INLINE mapC #-}

-- | Apply a transformation to all elements in a chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
mapCE :: (Monad m, Functor f) => (a -> b) -> ConduitT (f a) (f b) m ()
mapCE = CC.mapE
{-# INLINE mapCE #-}

-- | Apply a monomorphic transformation to all elements in a chunked stream.
--
-- Unlike @mapE@, this will work on types like @ByteString@ and @Text@ which
-- are @MonoFunctor@ but not @Functor@.
--
-- Subject to fusion
--
-- Since 1.0.0
omapCE :: (Monad m, MonoFunctor mono) => (Element mono -> Element mono) -> ConduitT mono mono m ()
omapCE = CC.omapE
{-# INLINE omapCE #-}

-- | See 'CC.concatMap'
concatMapC = CC.concatMap
{-# INLINE concatMapC #-}

-- | Apply the function to each element in the chunked stream, resulting in a
-- foldable value (e.g., a list). Then yield each of the individual values in
-- that foldable value separately.
--
-- Generalizes concatMap, mapMaybe, and mapFoldable.
--
-- Subject to fusion
--
-- Since 1.0.0
concatMapCE :: (Monad m, MonoFoldable mono, Monoid w)
           => (Element mono -> w)
           -> ConduitT mono w m ()
concatMapCE = CC.concatMapE
{-# INLINE concatMapCE #-}

-- | Stream up to n number of values downstream.
--
-- Note that, if downstream terminates early, not all values will be consumed.
-- If you want to force /exactly/ the given number of values to be consumed,
-- see 'takeExactly'.
--
-- Subject to fusion
--
-- Since 1.0.0
takeC :: Monad m => Int -> ConduitT a a m ()
takeC = CC.take
{-# INLINE takeC #-}

-- | Stream up to n number of elements downstream in a chunked stream.
--
-- Note that, if downstream terminates early, not all values will be consumed.
-- If you want to force /exactly/ the given number of values to be consumed,
-- see 'takeExactlyE'.
--
-- Since 1.0.0
takeCE :: (Monad m, Seq.IsSequence seq)
      => Seq.Index seq
      -> ConduitT seq seq m ()
takeCE = CC.takeE
{-# INLINE takeCE #-}

-- | Stream all values downstream that match the given predicate.
--
-- Same caveats regarding downstream termination apply as with 'take'.
--
-- Since 1.0.0
takeWhileC :: Monad m
          => (a -> Bool)
          -> ConduitT a a m ()
takeWhileC = CC.takeWhile
{-# INLINE takeWhileC #-}

-- | Stream all elements downstream that match the given predicate in a chunked stream.
--
-- Same caveats regarding downstream termination apply as with 'takeE'.
--
-- Since 1.0.0
takeWhileCE :: (Monad m, Seq.IsSequence seq)
           => (Element seq -> Bool)
           -> ConduitT seq seq m ()
takeWhileCE = CC.takeWhileE
{-# INLINE takeWhileCE #-}

-- | Consume precisely the given number of values and feed them downstream.
--
-- This function is in contrast to 'take', which will only consume up to the
-- given number of values, and will terminate early if downstream terminates
-- early. This function will discard any additional values in the stream if
-- they are unconsumed.
--
-- Note that this function takes a downstream @ConduitT@ as a parameter, as
-- opposed to working with normal fusion. For more information, see
-- <http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit>, the section
-- titled \"pipes and conduit: isolate\".
--
-- Since 1.0.0
takeExactlyC :: Monad m
            => Int
            -> ConduitT a b m r
            -> ConduitT a b m r
takeExactlyC = CC.takeExactly
{-# INLINE takeExactlyC #-}

-- | Same as 'takeExactly', but for chunked streams.
--
-- Since 1.0.0
takeExactlyCE :: (Monad m, Seq.IsSequence a)
             => Seq.Index a
             -> ConduitT a b m r
             -> ConduitT a b m r
takeExactlyCE = CC.takeExactlyE
{-# INLINE takeExactlyCE #-}

-- | See 'CC.concat'
concatC = CC.concat
{-# INLINE concatC #-}

-- | Keep only values in the stream passing a given predicate.
--
-- Subject to fusion
--
-- Since 1.0.0
filterC :: Monad m => (a -> Bool) -> ConduitT a a m ()
filterC = CC.filter
{-# INLINE filterC #-}

-- | Keep only elements in the chunked stream passing a given predicate.
--
-- Subject to fusion
--
-- Since 1.0.0
filterCE :: (Seq.IsSequence seq, Monad m) => (Element seq -> Bool) -> ConduitT seq seq m ()
filterCE = CC.filterE
{-# INLINE filterCE #-}

-- | Map values as long as the result is @Just@.
--
-- Since 1.0.0
mapWhileC :: Monad m => (a -> Maybe b) -> ConduitT a b m ()
mapWhileC = CC.mapWhile
{-# INLINE mapWhileC #-}

-- | Break up a stream of values into vectors of size n. The final vector may
-- be smaller than n if the total number of values is not a strict multiple of
-- n. No empty vectors will be yielded.
--
-- Since 1.0.0
conduitVector :: (V.Vector v a, PrimMonad m)
              => Int -- ^ maximum allowed size
              -> ConduitT a (v a) m ()
conduitVector = CC.conduitVector
{-# INLINE conduitVector #-}

-- | See 'CC.scanl'
scanlC = CC.scanl
{-# INLINE scanlC #-}

-- | See 'CC.mapAccumWhile'
mapAccumWhileC = CC.mapAccumWhile
{-# INLINE mapAccumWhileC #-}

-- | 'concatMap' with an accumulator.
--
-- Subject to fusion
--
-- Since 1.0.0
concatMapAccumC :: Monad m => (a -> accum -> (accum, [b])) -> accum -> ConduitT a b m ()
concatMapAccumC = CC.concatMapAccum
{-# INLINE concatMapAccumC #-}

-- | See 'CC.intersperse'
intersperseC = CC.intersperse
{-# INLINE intersperseC #-}

-- | See 'CC.slidingWindow'
slidingWindowC = CC.slidingWindow
{-# INLINE slidingWindowC #-}

-- | Split input into chunk of size 'chunkSize'
--
-- The last element may be smaller than the 'chunkSize' (see also
-- 'chunksOfExactlyE' which will not yield this last element)
--
-- @since 1.1.2
chunksOfCE :: (Monad m, Seq.IsSequence seq) => Seq.Index seq -> ConduitT seq seq m ()
chunksOfCE = CC.chunksOfE
{-# INLINE chunksOfCE #-}

-- | Split input into chunk of size 'chunkSize'
--
-- If the input does not split into chunks exactly, the remainder will be
-- leftover (see also 'chunksOfE')
--
-- @since 1.1.2
chunksOfExactlyCE :: (Monad m, Seq.IsSequence seq) => Seq.Index seq -> ConduitT seq seq m ()
chunksOfExactlyCE = CC.chunksOfExactlyE
{-# INLINE chunksOfExactlyCE #-}

-- | Apply base64-encoding to the stream.
--
-- Since 1.0.0
encodeBase64C :: Monad m => ConduitT ByteString ByteString m ()
encodeBase64C = CC.encodeBase64
{-# INLINE encodeBase64C #-}

-- | Apply base64-decoding to the stream. Will stop decoding on the first
-- invalid chunk.
--
-- Since 1.0.0
decodeBase64C :: Monad m => ConduitT ByteString ByteString m ()
decodeBase64C = CC.decodeBase64
{-# INLINE decodeBase64C #-}

-- | Apply URL-encoding to the stream.
--
-- Since 1.0.0
encodeBase64URLC :: Monad m => ConduitT ByteString ByteString m ()
encodeBase64URLC = CC.encodeBase64URL
{-# INLINE encodeBase64URLC #-}

-- | Apply lenient base64URL-decoding to the stream. Will stop decoding on the
-- first invalid chunk.
--
-- Since 1.0.0
decodeBase64URLC :: Monad m => ConduitT ByteString ByteString m ()
decodeBase64URLC = CC.decodeBase64URL
{-# INLINE decodeBase64URLC #-}

-- | Apply base16-encoding to the stream.
--
-- Subject to fusion
--
-- Since 1.0.0
encodeBase16C :: Monad m => ConduitT ByteString ByteString m ()
encodeBase16C = CC.encodeBase16
{-# INLINE encodeBase16C #-}

-- | Apply base16-decoding to the stream. Will stop decoding on the first
-- invalid chunk.
--
-- Since 1.0.0
decodeBase16C :: Monad m => ConduitT ByteString ByteString m ()
decodeBase16C = CC.decodeBase16
{-# INLINE decodeBase16C #-}

-- | Apply a monadic transformation to all values in a stream.
--
-- If you do not need the transformed values, and instead just want the monadic
-- side-effects of running the action, see 'mapM_'.
--
-- Subject to fusion
--
-- Since 1.0.0
mapMC :: Monad m => (a -> m b) -> ConduitT a b m ()
mapMC = CC.mapM
{-# INLINE mapMC #-}

-- | Apply a monadic transformation to all elements in a chunked stream.
--
-- Subject to fusion
--
-- Since 1.0.0
mapMCE :: (Monad m, Data.Traversable.Traversable f) => (a -> m b) -> ConduitT (f a) (f b) m ()
mapMCE = CC.mapME
{-# INLINE mapMCE #-}

-- | Apply a monadic monomorphic transformation to all elements in a chunked stream.
--
-- Unlike @mapME@, this will work on types like @ByteString@ and @Text@ which
-- are @MonoFunctor@ but not @Functor@.
--
-- Subject to fusion
--
-- Since 1.0.0
omapMCE :: (Monad m, MonoTraversable mono)
       => (Element mono -> m (Element mono))
       -> ConduitT mono mono m ()
omapMCE = CC.omapME
{-# INLINE omapMCE #-}

-- | See 'CC.concatMapM'
concatMapMC = CC.concatMapM
{-# INLINE concatMapMC #-}

-- | See 'CC.filterM'
filterMC = CC.filterM
{-# INLINE filterMC #-}

-- | Keep only elements in the chunked stream passing a given monadic predicate.
--
-- Subject to fusion
--
-- Since 1.0.0
filterMCE :: (Monad m, Seq.IsSequence seq) => (Element seq -> m Bool) -> ConduitT seq seq m ()
filterMCE = CC.filterME
{-# INLINE filterMCE #-}

-- | Apply a monadic action on all values in a stream.
--
-- This @Conduit@ can be used to perform a monadic side-effect for every
-- value, whilst passing the value through the @Conduit@ as-is.
--
-- > iterM f = mapM (\a -> f a >>= \() -> return a)
--
-- Subject to fusion
--
-- Since 1.0.0
iterMC :: Monad m => (a -> m ()) -> ConduitT a a m ()
iterMC = CC.iterM
{-# INLINE iterMC #-}

-- | See 'CC.scanlM'
scanlMC = CC.scanlM
{-# INLINE scanlMC #-}

-- | See 'CC.mapAccumWhileM'
mapAccumWhileMC = CC.mapAccumWhileM
{-# INLINE mapAccumWhileMC #-}

-- | 'concatMapM' with an accumulator.
--
-- Subject to fusion
--
-- Since 1.0.0
concatMapAccumMC :: Monad m => (a -> accum -> m (accum, [b])) -> accum -> ConduitT a b m ()
concatMapAccumMC = CC.concatMapAccumM
{-# INLINE concatMapAccumMC #-}

-- | Encode a stream of text as UTF8.
--
-- Subject to fusion
--
-- Since 1.0.0
encodeUtf8C :: (Monad m, DTE.Utf8 text binary) => ConduitT text binary m ()
encodeUtf8C = CC.encodeUtf8
{-# INLINE encodeUtf8C #-}

-- | Decode a stream of binary data as UTF8.
--
-- Since 1.0.0
decodeUtf8C :: MonadThrow m => ConduitT ByteString Text m ()
decodeUtf8C = CC.decodeUtf8
{-# INLINE decodeUtf8C #-}

-- | Decode a stream of binary data as UTF8, replacing any invalid bytes with
-- the Unicode replacement character.
--
-- Since 1.0.0
decodeUtf8LenientC :: MonadThrow m => ConduitT ByteString Text m ()
decodeUtf8LenientC = CC.decodeUtf8Lenient
{-# INLINE decodeUtf8LenientC #-}

-- | Stream in the entirety of a single line.
--
-- Like @takeExactly@, this will consume the entirety of the line regardless of
-- the behavior of the inner Conduit.
--
-- Since 1.0.0
lineC :: (Monad m, Seq.IsSequence seq, Element seq ~ Char)
     => ConduitT seq o m r
     -> ConduitT seq o m r
lineC = CC.line
{-# INLINE lineC #-}

-- | Same as 'line', but operates on ASCII/binary data.
--
-- Since 1.0.0
lineAsciiC :: (Monad m, Seq.IsSequence seq, Element seq ~ Word8)
          => ConduitT seq o m r
          -> ConduitT seq o m r
lineAsciiC = CC.lineAscii
{-# INLINE lineAsciiC #-}

-- | Insert a newline character after each incoming chunk of data.
--
-- Subject to fusion
--
-- Since 1.0.0
unlinesC :: (Monad m, Seq.IsSequence seq, Element seq ~ Char) => ConduitT seq seq m ()
unlinesC = CC.unlines
{-# INLINE unlinesC #-}

-- | Same as 'unlines', but operates on ASCII/binary data.
--
-- Subject to fusion
--
-- Since 1.0.0
unlinesAsciiC :: (Monad m, Seq.IsSequence seq, Element seq ~ Word8) => ConduitT seq seq m ()
unlinesAsciiC = CC.unlinesAscii
{-# INLINE unlinesAsciiC #-}

-- | Stream in the chunked input until an element matches a predicate.
--
-- Like @takeExactly@, this will consume the entirety of the prefix
-- regardless of the behavior of the inner Conduit.
takeExactlyUntilCE :: (Monad m, Seq.IsSequence seq)
                  => (Element seq -> Bool)
                  -> ConduitT seq o m r
                  -> ConduitT seq o m r
takeExactlyUntilCE = CC.takeExactlyUntilE
{-# INLINE takeExactlyUntilCE #-}

-- | See 'CC.linesUnbounded'
linesUnboundedC = CC.linesUnbounded
{-# INLINE linesUnboundedC #-}

-- | See 'CC.linesUnboundedAscii'
linesUnboundedAsciiC = CC.linesUnboundedAscii
{-# INLINE linesUnboundedAsciiC #-}

-- | See 'CC.splitOnUnboundedE'
splitOnUnboundedCE = CC.splitOnUnboundedE
{-# INLINE splitOnUnboundedCE #-}

-- | Generally speaking, yielding values from inside a Conduit requires
-- some allocation for constructors. This can introduce an overhead,
-- similar to the overhead needed to represent a list of values instead of
-- a vector. This overhead is even more severe when talking about unboxed
-- values.
--
-- This combinator allows you to overcome this overhead, and efficiently
-- fill up vectors. It takes two parameters. The first is the size of each
-- mutable vector to be allocated. The second is a function. The function
-- takes an argument which will yield the next value into a mutable
-- vector.
--
-- Under the surface, this function uses a number of tricks to get high
-- performance. For more information on both usage and implementation,
-- please see:
-- <https://www.fpcomplete.com/user/snoyberg/library-documentation/vectorbuilder>
--
-- Since 1.0.0
vectorBuilderC :: (PrimMonad m, PrimMonad n, V.Vector v e, PrimState m ~ PrimState n)
              => Int -- ^ size
              -> ((e -> n ()) -> ConduitT i Void m r)
              -> ConduitT i (v e) m r
vectorBuilderC = CC.vectorBuilder
{-# INLINE vectorBuilderC #-}

-- | Consume a source with a strict accumulator, in a way piecewise defined by
-- a controlling stream. The latter will be evaluated until it terminates.
--
-- >>> let f a s = liftM (:s) $ mapC (*a) =$ CL.take a
-- >>> reverse $ runIdentity $ yieldMany [0..3] $$ mapAccumS f [] (yieldMany [1..])
-- [[],[1],[4,6],[12,15,18]] :: [[Int]]
mapAccumSC
  :: Monad m
  => (a -> s -> ConduitT b Void m s)
  -> s
  -> ConduitT () b m ()
  -> ConduitT a Void m s
mapAccumSC = CC.mapAccumS
{-# INLINE mapAccumSC #-}

-- | Run a consuming conduit repeatedly, only stopping when there is no more
-- data available from upstream.
--
-- Since 1.0.0
peekForeverC :: Monad m => ConduitT i o m () -> ConduitT i o m ()
peekForeverC = CC.peekForever
{-# INLINE peekForeverC #-}

-- | Run a consuming conduit repeatedly, only stopping when there is no more
-- data available from upstream.
--
-- In contrast to 'peekForever', this function will ignore empty
-- chunks of data. So for example, if a stream of data contains an
-- empty @ByteString@, it is still treated as empty, and the consuming
-- function is not called.
--
-- @since 1.0.6
peekForeverCE :: (Monad m, MonoFoldable i)
             => ConduitT i o m ()
             -> ConduitT i o m ()
peekForeverCE = CC.peekForeverE
{-# INLINE peekForeverCE #-}
