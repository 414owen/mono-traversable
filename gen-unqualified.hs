import Data.List
import Data.Maybe
import Control.Monad.Trans.Writer
import Control.Monad

main :: IO ()
main = do
    orig <- readFile "Data/Conduit/Combinators.hs"
    let origLines = lines orig
        (exports, body) = break isImport $ drop 1 $ dropWhile (/= starting) origLines
        imports = takeWhile (/= "-- END IMPORTS") $ dropWhile (/= "-- BEGIN IMPORTS") origLines
        langs = filter ("{-# LANGUAGE " `isPrefixOf`) origLines
        docs = execWriter $ parseDocs body
        (x, y) = runWriter $ mapM process exports
    putStrLn "-- WARNING: This module is autogenerated"
    putStrLn "{-# OPTIONS_HADDOCK not-home #-}"
    mapM_ putStrLn langs
    putStrLn "module Data.Conduit.Combinators.Unqualified"
    mapM_ putStrLn x
    putStrLn "import qualified Data.Conduit.Combinators as CC"
    mapM_ putStrLn imports
    forM_ y $ \(old, new) -> do
        putStrLn ""
        case lookup old docs of
            Nothing -> putStrLn $ "-- | See 'CC." ++ old ++ "'"
            Just (docs', sig) -> do
                mapM_ putStrLn docs'
                forM_ sig $ \l -> putStrLn $
                    case stripPrefix old l of
                        Nothing -> l
                        Just l'' -> new ++ l''
        putStrLn $ new ++ " = CC." ++ old
        putStrLn $ "{-# INLINE " ++ new ++ " #-}"

starting = "module Data.Conduit.Combinators"
isImport = ("import " `isPrefixOf`)

parseDocs [] = return ()
parseDocs (x0:xs0)
    | isDoc x0 = loop (x0:) xs0
    | otherwise = parseDocs xs0
  where
    isDoc = ("--" `isPrefixOf`)

    loop front [] = return ()
    loop front (x:xs)
        | isDoc x = loop (front . (x:)) xs
        | otherwise = loop2 (front []) id (x:xs)

    loop2 docs front [] = return ()
    loop2 docs front (x:xs)
        | '=' `elem` x && not (" => " `isInfixOf` x) = do
            when (null name) $ error $ "null name in loop2: " ++ show (docs, front [], x)
            tell [(name, (docs, front []))]
            parseDocs xs
        | otherwise = loop2 docs (front . (x:)) xs
      where
        name = takeWhile (/= ' ') x

process l
    | null rest || head rest `elem` "(-)" = return $ dropLevel l
    | otherwise = do
        let orig =
                case dropWhile (/= '.') rest of
                    '.':orig' -> orig'
                    _ -> rest
            newName = tweak orig
        tell [(orig, newName)]
        return $ lead ++ newName
  where
    (lead, rest) = span (`elem` " ,") l

tweak orig
    | any (`isPrefixOf` orig) (words "await yield source sink conduit") = orig
    | otherwise =
        case reverse orig of
            'E':orig' -> reverse orig' ++ "CE"
            _ -> orig ++ "C"

dropLevel [] = []
dropLevel ('*':rest) = '*':'*':rest
dropLevel (x:y) = x : dropLevel y
