import Data.List
import Data.Maybe
import Control.Monad.Trans.Writer
import Control.Monad

main :: IO ()
main = do
    orig <- readFile "Data/Conduit/Combinators.hs"
    let (exports, body) = break isImport $ drop 1 $ dropWhile (/= starting) $ lines orig
        docs = execWriter $ parseDocs body
        (x, y) = runWriter $ mapM process exports
    putStrLn "-- WARNING: This module is autogenerated"
    putStrLn "{-# OPTIONS_HADDOCK not-home #-}"
    putStrLn "{-# LANGUAGE NoMonomorphismRestriction #-}"
    putStrLn "module Data.Conduit.Combinators.Unqualified"
    mapM_ putStrLn x
    putStrLn "import qualified Data.Conduit.Combinators as CC"
    forM_ y $ \(old, new) -> do
        putStrLn ""
        case lookup old docs of
            Nothing -> putStrLn $ "-- | See 'CC." ++ old ++ "'"
            Just docs' -> mapM_ putStrLn docs'
        putStrLn $ new ++ " = CC." ++ old
        putStrLn $ "{-# INLINE " ++ new ++ "#-}"

starting = "module Data.Conduit.Combinators"
isImport = ("import " `isPrefixOf`)

parseDocs [] = return ()
parseDocs (x0:xs0)
    | isDoc x0 = loop (x0:) xs0
    | otherwise = parseDocs xs0
  where
    isDoc = ("--" `isPrefixOf`)

    loop front [] = return ()
    loop front (x:xs)
        | isDoc x = loop (front . (x:)) xs
        | otherwise = do
            tell [(name, front [])]
            parseDocs xs
      where
        name = takeWhile (/= ' ') x

process l
    | null rest || head rest `elem` "(-)" = return $ dropLevel l
    | otherwise = do
        let orig =
                case dropWhile (/= '.') rest of
                    '.':orig' -> orig'
                    _ -> rest
            newName = tweak orig
        tell [(orig, newName)]
        return $ lead ++ newName
  where
    (lead, rest) = span (`elem` " ,") l

tweak orig
    | any (`isPrefixOf` orig) (words "yield source sink conduit") = orig
    | otherwise =
        case reverse orig of
            'E':orig' -> reverse orig' ++ "CE"
            _ -> orig ++ "C"

dropLevel [] = []
dropLevel ('*':rest) = '*':'*':rest
dropLevel (x:y) = x : dropLevel y
